# Specification: Ballerina Persist Tools

_Owners_: @daneshk @MadhukaHarith92 @sahanHe  
_Reviewers_: @daneshk  
_Created_: 2022/07/26   
_Updated_: 2022/08/17  
_Edition_: Swan Lake  

## Introduction
This is the specification for the Persist Tools of [Ballerina language](https://ballerina.io/), which supports several operations on Ballerina Persistent Layer on top of Ballerina SQL modules and allow performing DB operations easily without writing any SQL statements.

The Persist Tools specification has evolved and may continue to evolve in the future. The released versions of the specification can be found under the relevant GitHub tag.

If you have any feedback or suggestions about the tool, start a discussion via a [GitHub issue](https://github.com/ballerina-platform/ballerina-standard-library/issues) or in the [Slack channel](https://ballerina.io/community/). Based on the outcome of the discussion, the specification and implementation can be updated. Community feedback is always welcome. Any accepted proposal, which affects the specification is stored under `/docs/proposals`. Proposals under discussion can be found with the label `type/proposal` in GitHub.

The conforming implementation of the specification is released and included in the distribution. Any deviation from the specification is considered a bug.

## Contents

1. [Overview](#1-overview)
2. [Generating Database Configurations](#2-generating-database-configurations)
3. [Generating Client Objects](#3-generating-client-objects)

## 1. Overview
This specification elaborates on the operations available in the CLI Tool.

## 2. Generating Database Configurations
The first step is to create database configurations. Users can do this by executing `bal persist init` command inside a Ballerina project. This will add the following entry to the `Config.toml` file inside the project.

```ballerina
host = "localhost"
port = 3306
user = "root"
password = ""
database = ""
```

Users can then update the above entry with their database configurations.

- The `bal persist init` command should be executed inside a valid Ballerina project. If not, an error will be thrown.
- If there isn't a `Config.toml` file inside the project root directory, a new `Config.toml` file will get created with the aforementioned configuration.
- If there already is a `Config.toml` file inside the project root directory and there is no entry as `ballerina.persist`, a new entry will be added to the existing `Config.toml` file.
- If there already is a `Config.toml` file inside the project root directory and there already is an entry as `ballerina.persist`, it will be overridden with the above values.

## 3. Generating Client Objects
Users can define database entities in their Ballerina projects. They can generate client objects corresponding to these entities by executing `bal persist generate` command. Users can then use these client objects to perform database operations programmatically without having to write SQL statements.

Consider the following Ballerina project named `medical-center`.
```
medical-center
├── Ballerina.toml
├── entities.bal
└── main.bal
```

Inside the Ballerina project, users can define `Entity` records as follows.

```ballerina
import ballerina/time;
import ballerina/persist;

@persist:Entity {
    key: ["needId"],
    tableName: "MedicalNeeds"
}
public type MedicalNeed record {|
    @persist:AutoIncrement
    readonly int needId = -1;

    int itemId;
    int beneficiaryId;
    time:Civil period;
    string urgency;
    int quantity;
|};
```

In this example, `MedicalNeed` is an entity with the attributes `itemId`, `beneficiaryId`, `period`, `urgency`, and `quantity`. When users execute `bal persist generate` inside a Ballerina project, a new module named `generated_clients` will be created. Inside the `generated_clients` module, Ballerina files will be generated encapsulating the client object with respect to each entity defined in the project. The following is the project structure after the command execution.
```
medical-center
├── Ballerina.toml
├── entities.bal
├── main.bal
└── modules
    └── generated_clients
        └── medicalneed_client.bal
```

When users execute `bal persist generate` inside the project, the following client object is generated inside the `medicalneed_client.bal`.

```ballerina
import ballerina/sql;
import ballerinax/mysql;
import ballerina/time;
import ballerina/persist;

client class MedicalNeedClient {

    private final string entityName = "MedicalNeed";
    private final sql:ParameterizedQuery tableName = `MedicalNeeds`;

    private final map<persist:FieldMetadata> fieldMetadata = {
        needId: {columnName: "needId", 'type: int, autoGenerated: true},
        itemId: {columnName: "itemId", 'type: int},
        beneficiaryId: {columnName: "beneficiaryId", 'type: int},
        period: {columnName: "period", 'type: time:Civil},
        urgency: {columnName: "urgency", 'type: string},
        quantity: {columnName: "quantity", 'type: int}
    };
    private string[] keyFields = ["needId"];

    private persist:SQLClient persistClient;

    public function init() returns persist:Error? {
        mysql:Client dbClient = check new (host = HOST, user = USER, password = PASSWORD, database = DATABASE, port = PORT);
        self.persistClient = check new (self.entityName, self.tableName, self.fieldMetadata, self.keyFields, dbClient);
    }

    remote function create(MedicalNeed value) returns int|persist:Error? {
        sql:ExecutionResult result = check self.persistClient.runInsertQuery(value);
        return <int>result.lastInsertId;
    }

    remote function readByKey(int key) returns MedicalNeed|persist:Error {
        return (check self.persistClient.runReadByKeyQuery(key)).cloneWithType(MedicalNeed);
    }

    remote function read(map<anydata>? filter = ()) returns stream<MedicalNeed, persist:Error?>|persist:Error {
        stream<anydata, error?> result = check self.persistClient.runReadQuery(filter);
        return new stream<MedicalNeed, error?>(new MedicalNeedStream(result));
    }

    remote function update(record {} 'object, map<anydata> filter) returns persist:Error? {
        _ = check self.persistClient.runUpdateQuery('object, filter);
    }

    remote function delete(map<anydata> filter) returns persist:Error? {
        _ = check self.persistClient.runDeleteQuery(filter);
    }

    function close() returns persist:Error? {
        return self.persistClient.close();
    }

}

public class MedicalNeedStream {

    private stream<anydata, persist:Error?> anydataStream;

    public isolated function init(stream<anydata, persist:Error?> anydataStream) {
        self.anydataStream = anydataStream;
    }

    public isolated function next() returns record {|MedicalNeed value;|}|persist:Error? {
        var streamValue = self.anydataStream.next();
        if streamValue is () {
            return streamValue;
        } else if (streamValue is error) {
            return streamValue;
        } else {
            record {|MedicalNeed value;|} nextRecord = {value: check streamValue.value.cloneWithType(MedicalNeed)};
            return nextRecord;
        }
    }

    public isolated function close() returns persist:Error? {
        return self.anydataStream.close();
    }
}
```
