/*
 * Copyright (c) 2023, WSO2 LLC. (https://www.wso2.com) All Rights Reserved.
 *
 * WSO2 LLC. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package io.ballerina.persist.components.syntax;

import io.ballerina.compiler.syntax.tree.AbstractNodeFactory;
import io.ballerina.compiler.syntax.tree.IdentifierToken;
import io.ballerina.compiler.syntax.tree.ImportDeclarationNode;
import io.ballerina.compiler.syntax.tree.ImportOrgNameNode;
import io.ballerina.compiler.syntax.tree.ImportPrefixNode;
import io.ballerina.compiler.syntax.tree.MinutiaeList;
import io.ballerina.compiler.syntax.tree.ModuleMemberDeclarationNode;
import io.ballerina.compiler.syntax.tree.ModulePartNode;
import io.ballerina.compiler.syntax.tree.NodeFactory;
import io.ballerina.compiler.syntax.tree.NodeList;
import io.ballerina.compiler.syntax.tree.NodeParser;
import io.ballerina.compiler.syntax.tree.SeparatedNodeList;
import io.ballerina.compiler.syntax.tree.SyntaxKind;
import io.ballerina.compiler.syntax.tree.SyntaxTree;
import io.ballerina.compiler.syntax.tree.Token;
import io.ballerina.persist.models.Entity;
import io.ballerina.persist.models.EntityField;
import io.ballerina.persist.models.Module;
import io.ballerina.persist.models.Relation;
import io.ballerina.persist.nodegenerator.BalSyntaxConstants;
import io.ballerina.persist.nodegenerator.SyntaxTokenConstants;
import io.ballerina.tools.text.TextDocument;
import io.ballerina.tools.text.TextDocuments;

import java.util.Locale;

/**
 * This class implements the utility methods for syntax generate.
 *
 * @since 0.3.1
 */
public class Utils {

    public static String getStringWithUnderScore(String entityName) {
        StringBuilder outputString = new StringBuilder();
        String[] splitedStrings = Utils.stripEscapeCharacter(entityName).split(
                BalSyntaxConstants.REGEX_FOR_SPLIT_BY_CAPITOL_LETTER);
        for (String splitedString : splitedStrings) {
            if (outputString.length() != 0) {
                outputString.append(BalSyntaxConstants.UNDERSCORE);
            }
            outputString.append(splitedString.toUpperCase(Locale.ENGLISH));
        }
        if (entityName.startsWith(BalSyntaxConstants.SINGLE_QUOTE)) {
            return BalSyntaxConstants.SINGLE_QUOTE + outputString;
        }
        return outputString.toString();
    }

    public static String stripEscapeCharacter(String fieldName) {
        return fieldName.startsWith(BalSyntaxConstants.SINGLE_QUOTE) ? fieldName.substring(1) : fieldName;
    }

    public static ImportDeclarationNode getImportDeclarationNode(String orgName, String moduleName,
                                                                  ImportPrefixNode prefix) {
        Token orgNameToken = AbstractNodeFactory.createIdentifierToken(orgName);
        ImportOrgNameNode importOrgNameNode = NodeFactory.createImportOrgNameNode(
                orgNameToken,
                SyntaxTokenConstants.SYNTAX_TREE_SLASH);
        Token moduleNameToken = AbstractNodeFactory.createIdentifierToken(moduleName);
        SeparatedNodeList<IdentifierToken> moduleNodeList = AbstractNodeFactory
                .createSeparatedNodeList(moduleNameToken);

        return NodeFactory.createImportDeclarationNode(
                SyntaxTokenConstants.SYNTAX_TREE_KEYWORD_IMPORT,
                importOrgNameNode,
                moduleNodeList,
                prefix,
                SyntaxTokenConstants.SYNTAX_TREE_SEMICOLON);
    }

    public static SyntaxTree generateTypeSyntaxTree(Module entityModule) {
        NodeList<ImportDeclarationNode> imports = AbstractNodeFactory.createEmptyNodeList();
        NodeList<ModuleMemberDeclarationNode> moduleMembers = AbstractNodeFactory.createEmptyNodeList();
        MinutiaeList commentMinutiaeList = createCommentMinutiaeList(String.format(
                BalSyntaxConstants.AUTO_GENERATED_COMMENT_WITH_REASON, entityModule.getModuleName()));

        for (String modulePrefix : entityModule.getImportModulePrefixes()) {
            if (imports.isEmpty()) {
                imports = imports.add(getImportDeclarationNodeWithAutogeneratedComment(
                        BalSyntaxConstants.KEYWORD_BALLERINA, modulePrefix,
                        commentMinutiaeList, null));
            } else {
                imports.add(getImportDeclarationNode(modulePrefix));
            }
        }
        boolean includeAutoGeneratedComment = imports.isEmpty();
        for (Entity entity : entityModule.getEntityMap().values()) {
            boolean hasRelations = false;
            for (EntityField field : entity.getFields()) {
                if (field.getRelation() != null) {
                    hasRelations = true;
                    break;
                }
            }
            if (includeAutoGeneratedComment) {
                moduleMembers = moduleMembers.add(createEntityRecord(entity, includeAutoGeneratedComment,
                        entityModule.getModuleName()));
                includeAutoGeneratedComment = false;
            } else {
                moduleMembers = moduleMembers.add(createEntityRecord(entity, includeAutoGeneratedComment,
                        entityModule.getModuleName()));
            }
            moduleMembers = moduleMembers.add(createEntityRecordOptionalized(entity));
            if (hasRelations) {
                moduleMembers = moduleMembers.add(createEntityRecordWithRelation(entity));
            }
            moduleMembers = moduleMembers.add(createEntityTargetType(entity, hasRelations));
            moduleMembers = moduleMembers.add(NodeParser.parseModuleMemberDeclaration(
                    String.format("public type %sInsert %s;", entity.getEntityName(),
                            entity.getEntityName())));
            moduleMembers = moduleMembers.add(createUpdateRecord(entity));
        }
        Token eofToken = AbstractNodeFactory.createIdentifierToken(BalSyntaxConstants.EMPTY_STRING);
        ModulePartNode modulePartNode = NodeFactory.createModulePartNode(imports, moduleMembers, eofToken);
        TextDocument textDocument = TextDocuments.from(BalSyntaxConstants.EMPTY_STRING);
        SyntaxTree balTree = SyntaxTree.from(textDocument);

        return balTree.modifyWith(modulePartNode);
    }

    private static ImportDeclarationNode getImportDeclarationNode(String moduleName) {
        Token orgNameToken = AbstractNodeFactory.createIdentifierToken(BalSyntaxConstants.KEYWORD_BALLERINA);
        ImportOrgNameNode importOrgNameNode = NodeFactory.createImportOrgNameNode(
                orgNameToken,
                SyntaxTokenConstants.SYNTAX_TREE_SLASH);
        Token moduleNameToken = AbstractNodeFactory.createIdentifierToken(moduleName);
        SeparatedNodeList<IdentifierToken> moduleNodeList = AbstractNodeFactory
                .createSeparatedNodeList(moduleNameToken);

        return NodeFactory.createImportDeclarationNode(
                SyntaxTokenConstants.SYNTAX_TREE_KEYWORD_IMPORT,
                importOrgNameNode,
                moduleNodeList,
                null,
                SyntaxTokenConstants.SYNTAX_TREE_SEMICOLON);
    }

    private static ModuleMemberDeclarationNode createEntityRecord(Entity entity, boolean includeAutogeneratedComment,
                                                                  String moduleName) {
        StringBuilder recordFields = new StringBuilder();
        for (EntityField field : entity.getFields()) {
            if (entity.getKeys().stream().anyMatch(key -> key == field)) {
                recordFields.append(BalSyntaxConstants.KEYWORD_READONLY);
                recordFields.append(BalSyntaxConstants.SPACE);
                recordFields.append(field.getFieldType());
                if (field.isArrayType()) {
                    recordFields.append(BalSyntaxConstants.ARRAY);
                }
                recordFields.append(BalSyntaxConstants.SPACE);
                recordFields.append(field.getFieldName());
                recordFields.append(BalSyntaxConstants.SEMICOLON);
                recordFields.append(BalSyntaxConstants.SPACE);
            } else if (field.getRelation() != null) {
                if (field.getRelation().isOwner()) {
                    for (Relation.Key key : field.getRelation().getKeyColumns()) {
                        recordFields.append(key.getType());
                        recordFields.append(BalSyntaxConstants.SPACE);
                        recordFields.append(key.getField());
                        recordFields.append(BalSyntaxConstants.SEMICOLON);
                        recordFields.append(BalSyntaxConstants.SPACE);
                    }
                }
            } else {
                recordFields.append(field.isOptionalType() ? field.getFieldType() + (field.isArrayType() ?
                        BalSyntaxConstants.ARRAY : "") + BalSyntaxConstants.QUESTION_MARK : field.getFieldType() +
                        (field.isArrayType() ? BalSyntaxConstants.ARRAY : ""));
                recordFields.append(BalSyntaxConstants.SPACE);
                recordFields.append(field.getFieldName());
                recordFields.append(BalSyntaxConstants.SEMICOLON);
                recordFields.append(BalSyntaxConstants.SPACE);
            }

        }
        if (includeAutogeneratedComment) {
            String commentBuilder = BalSyntaxConstants.AUTOGENERATED_FILE_COMMENT + System.lineSeparator() +
                    System.lineSeparator() + String.format(BalSyntaxConstants.AUTO_GENERATED_COMMENT_WITH_REASON,
                    moduleName) + System.lineSeparator() + BalSyntaxConstants.COMMENT_SHOULD_NOT_BE_MODIFIED +
                    System.lineSeparator() + System.lineSeparator() + "public type %s record {| %s |};";
            return NodeParser.parseModuleMemberDeclaration(String.format(commentBuilder,
                    entity.getEntityName().trim(), recordFields));
        }
        return NodeParser.parseModuleMemberDeclaration(String.format("public type %s record {| %s |};",
                entity.getEntityName().trim(), recordFields));
    }


    private static ModuleMemberDeclarationNode createEntityRecordOptionalized(Entity entity) {
        StringBuilder recordFields = new StringBuilder();
        for (EntityField field : entity.getFields()) {
            if (field.getRelation() != null) {
                if (field.getRelation().isOwner()) {
                    for (Relation.Key key : field.getRelation().getKeyColumns()) {
                        recordFields.append(key.getType());
                        recordFields.append(BalSyntaxConstants.SPACE);
                        recordFields.append(key.getField());
                        recordFields.append(BalSyntaxConstants.QUESTION_MARK);
                        recordFields.append(BalSyntaxConstants.SEMICOLON);
                        recordFields.append(BalSyntaxConstants.SPACE);
                    }
                }
            } else {
                recordFields.append(field.isOptionalType() ? field.getFieldType() + (field.isArrayType() ?
                        BalSyntaxConstants.ARRAY : "") + BalSyntaxConstants.QUESTION_MARK : field.getFieldType() +
                        (field.isArrayType() ? BalSyntaxConstants.ARRAY : ""));
                recordFields.append(BalSyntaxConstants.SPACE);
                recordFields.append(field.getFieldName());
                recordFields.append(BalSyntaxConstants.QUESTION_MARK);
                recordFields.append(BalSyntaxConstants.SEMICOLON);
                recordFields.append(BalSyntaxConstants.SPACE);
            }

        }
        return NodeParser.parseModuleMemberDeclaration(String.format("public type %sOptionalized record {| %s |};",
                entity.getEntityName().trim(), recordFields));
    }

    private static ModuleMemberDeclarationNode createEntityRecordWithRelation(Entity entity) {
        StringBuilder recordFields = new StringBuilder();
        recordFields.append(String.format("*%sOptionalized;", entity.getEntityName()));
        for (EntityField field : entity.getFields()) {
            if (field.getRelation() != null) {
                recordFields.append(String.format("%sOptionalized", field.getFieldType()));
                if (field.isArrayType()) {
                    recordFields.append("[]");
                }
                recordFields.append(BalSyntaxConstants.SPACE);
                recordFields.append(field.getFieldName());
                recordFields.append(BalSyntaxConstants.QUESTION_MARK);
                recordFields.append(BalSyntaxConstants.SEMICOLON);
                recordFields.append(BalSyntaxConstants.SPACE);
            }

        }
        return NodeParser.parseModuleMemberDeclaration(String.format("public type %sWithRelations record {| %s |};",
                entity.getEntityName().trim(), recordFields));
    }

    private static ModuleMemberDeclarationNode createEntityTargetType(Entity entity, boolean hasRelations) {
        return NodeParser.parseModuleMemberDeclaration(String.format("public type %sTargetType " +
                        "typedesc<%s>;",
                entity.getEntityName().trim(), entity.getEntityName().trim() +
                        (hasRelations ? "WithRelations" : "Optionalized")));
    }

    private static ModuleMemberDeclarationNode createUpdateRecord(Entity entity) {
        StringBuilder recordFields = new StringBuilder();
        for (EntityField field : entity.getFields()) {
            if (entity.getKeys().stream().noneMatch(key -> key == field)) {
                if (field.getRelation() != null) {
                    if (field.getRelation().isOwner()) {
                        for (Relation.Key key : field.getRelation().getKeyColumns()) {
                            recordFields.append(key.getType());
                            recordFields.append(" ");
                            recordFields.append(key.getField());
                            recordFields.append(BalSyntaxConstants.QUESTION_MARK);
                            recordFields.append(BalSyntaxConstants.SEMICOLON);
                            recordFields.append(BalSyntaxConstants.SPACE);
                        }
                    }
                } else {
                    recordFields.append(field.isOptionalType()
                            ? field.getFieldType() + (field.isArrayType() ? BalSyntaxConstants.ARRAY : "") +
                            BalSyntaxConstants.QUESTION_MARK : field.getFieldType() + (field.isArrayType() ?
                            BalSyntaxConstants.ARRAY : ""));
                    recordFields.append(BalSyntaxConstants.SPACE);
                    recordFields.append(field.getFieldName());
                    recordFields.append(BalSyntaxConstants.QUESTION_MARK);
                    recordFields.append(BalSyntaxConstants.SEMICOLON);
                    recordFields.append(BalSyntaxConstants.SPACE);
                }
            }

        }
        return NodeParser.parseModuleMemberDeclaration(String.format("public type %sUpdate record {| %s |};",
                entity.getEntityName().trim(), recordFields));
    }

    private static ImportDeclarationNode getImportDeclarationNodeWithAutogeneratedComment(
            String orgName, String moduleName, MinutiaeList commentMinutiaeList, ImportPrefixNode prefix) {
        Token orgNameToken = AbstractNodeFactory.createIdentifierToken(orgName);
        ImportOrgNameNode importOrgNameNode = NodeFactory.createImportOrgNameNode(
                orgNameToken,
                SyntaxTokenConstants.SYNTAX_TREE_SLASH);
        Token moduleNameToken = AbstractNodeFactory.createIdentifierToken(moduleName);
        SeparatedNodeList<IdentifierToken> moduleNodeList = AbstractNodeFactory
                .createSeparatedNodeList(moduleNameToken);
        Token importToken = NodeFactory.createToken(SyntaxKind.IMPORT_KEYWORD,
                commentMinutiaeList, NodeFactory.createMinutiaeList(AbstractNodeFactory
                        .createWhitespaceMinutiae(BalSyntaxConstants.SPACE)));
        return NodeFactory.createImportDeclarationNode(
                importToken,
                importOrgNameNode,
                moduleNodeList,
                prefix,
                SyntaxTokenConstants.SYNTAX_TREE_SEMICOLON);
    }

    protected static MinutiaeList createCommentMinutiaeList(String comment) {
        return NodeFactory.createMinutiaeList(
                AbstractNodeFactory.createCommentMinutiae(BalSyntaxConstants.AUTOGENERATED_FILE_COMMENT),
                AbstractNodeFactory.createEndOfLineMinutiae(System.lineSeparator()),
                AbstractNodeFactory.createEndOfLineMinutiae(System.lineSeparator()),
                AbstractNodeFactory.createCommentMinutiae(comment),
                AbstractNodeFactory.createEndOfLineMinutiae(System.lineSeparator()),
                AbstractNodeFactory.createCommentMinutiae(BalSyntaxConstants.COMMENT_SHOULD_NOT_BE_MODIFIED),
                AbstractNodeFactory.createEndOfLineMinutiae(System.lineSeparator()),
                AbstractNodeFactory.createEndOfLineMinutiae(System.lineSeparator()));
    }

    public static String getPrimaryKeys(Entity entity, boolean addDoubleQuotes) {
        StringBuilder keyFields = new StringBuilder();
        for (EntityField key : entity.getKeys()) {
            if (keyFields.length() != 0) {
                keyFields.append(BalSyntaxConstants.COMMA_SPACE);
            }
            if (addDoubleQuotes) {
                keyFields.append("\"").append(Utils.stripEscapeCharacter(key.getFieldName())).append("\"");
            } else {
                keyFields.append(Utils.stripEscapeCharacter(key.getFieldName()));
            }
        }
        return keyFields.toString();
    }
}
